import * as React from 'react';
import useLatest from './useLatest';
export default function useHighlighted({
  inputValue,
  setInputValue,
  data,
  multiple,
  values,
  onChangeMultiple,
  onChangeSingle,
  inputRef,
  setVisible
}) {
  const [highlightedIndex, setHighlightedIndex] = React.useState(0);
  const highlightedRef = useLatest(highlightedIndex);
  const previousData = usePrevious(data);
  React.useEffect(() => {
    if (previousData) {
      const previousItem = previousData[highlightedRef.current];
      const currentItem = data === null || data === void 0 ? void 0 : data.indexOf(previousItem);

      if (currentItem && currentItem >= 0) {
        setHighlightedIndex(currentItem);
        return;
      }
    }

    const exists = data === null || data === void 0 ? void 0 : data[highlightedRef.current];

    if (exists) {
      return;
    }

    const before = data === null || data === void 0 ? void 0 : data[highlightedRef.current - 1];

    if (before) {
      setHighlightedIndex(prev => prev - 1);
      return;
    }

    setHighlightedIndex(0);
  }, [data, previousData, setHighlightedIndex, highlightedRef]);
  const removeLast = React.useCallback(() => {
    if (multiple) {
      onChangeMultiple((values || []).filter((_, i) => i !== (values || []).length - 1));
    }
  }, [multiple, onChangeMultiple, values]);
  const pressHighlighted = React.useCallback(() => {
    if (multiple) {
      const selectedOption = data === null || data === void 0 ? void 0 : data[highlightedRef.current];

      if (selectedOption) {
        onChangeMultiple([...(values || []), selectedOption]);
      }

      setInputValue('');
    } else {
      var _inputRef$current;

      const selectedOption = data === null || data === void 0 ? void 0 : data[highlightedRef.current];
      onChangeSingle(selectedOption);
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
      setVisible(false);
    }
  }, [data, inputRef, setInputValue, setVisible, highlightedRef, multiple, onChangeMultiple, onChangeSingle, values]);
  const dataRef = useLatest(data);
  const handleKeyPress = React.useCallback(e => {
    var _dataRef$current;

    const dataLength = ((_dataRef$current = dataRef.current) === null || _dataRef$current === void 0 ? void 0 : _dataRef$current.length) || 0;
    const lastIndex = dataLength - 1;
    const key = e.nativeEvent.key;

    switch (key) {
      case 'Backspace':
        if (inputValue === '') {
          removeLast();
        }

        break;

      case 'Enter':
        if (dataLength === 0) {
          return;
        }

        pressHighlighted();
        break;

      case 'ArrowDown':
        if ((dataLength || 0) - 1 >= highlightedRef.current + 1) {
          setHighlightedIndex(prev => prev + 1);
        } else {
          setHighlightedIndex(0);
        }

        break;

      case 'ArrowUp':
        if (highlightedRef.current >= 1) {
          setHighlightedIndex(prev => prev - 1);
        } else {
          setHighlightedIndex(lastIndex);
        }

        break;

      case 'Home':
        setHighlightedIndex(0);
        break;

      case 'End':
        if (dataLength > 0) {
          setHighlightedIndex(lastIndex);
        }

        break;

      default:
    }
  }, [dataRef, highlightedRef, inputValue, pressHighlighted, removeLast]);
  return {
    handleKeyPress,
    highlightedIndex
  };
}

function usePrevious(value) {
  const ref = React.useRef();
  React.useLayoutEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
//# sourceMappingURL=useHighlighted.js.map