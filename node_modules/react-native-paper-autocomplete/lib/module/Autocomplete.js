function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import * as React from 'react';
import { View, StyleSheet, TextInput as NativeTextInput, FlatList, SectionList // useWindowDimensions,
} from 'react-native';
import { ActivityIndicator, Chip, IconButton, List, TextInput, useTheme } from 'react-native-paper';
import Color from 'color';
import useLatest from './useLatest';
import useAutomaticScroller from './useAutomaticScroller';
import AutocompleteItem from './AutocompleteItem';
import useHighlighted from './useHighlighted';
import PortalContent from './PortalContent';
import useComponentDimensions from './useComponentDimensions';
import PositionedSurface from './PositionedSurface';
import Animated, { useAnimatedRef, useAnimatedStyle, useDerivedValue } from 'react-native-reanimated';
import { useAutocomplete } from './AutocompleteContext'; // https://ej2.syncfusion.com/react/documentation/drop-down-list/accessibility/

export function getFlatListItemLayout(_, index) {
  return {
    length: 63,
    offset: 63 * index,
    index
  };
} // const AnimatedTextInput = createElement(TextInput);

export function defaultFilterOptions(a, {
  isFocusedAndValueIsSameAsSearch,
  inputValue,
  getOptionLabel,
  getOptionDescription
}) {
  if (isFocusedAndValueIsSameAsSearch) {
    return a;
  }

  return a === null || a === void 0 ? void 0 : a.filter(o => {
    const oAny = o;

    if (!inputValue) {
      return true;
    }

    const search = inputValue.toLowerCase();
    const label = getOptionLabel(oAny) || '';
    const description = (getOptionDescription === null || getOptionDescription === void 0 ? void 0 : getOptionDescription(oAny)) || '';
    return label.toLowerCase().includes(search) || description.toLowerCase().includes(search);
  });
}

function removeSelected(a, {
  value: rValue,
  multiple,
  getOptionValue
}) {
  return a === null || a === void 0 ? void 0 : a.filter(o => {
    let selected = multiple ? rValue === null || rValue === void 0 ? void 0 : rValue.some(v => getOptionValue(v) === getOptionValue(o)) : rValue && getOptionValue(rValue) === getOptionValue(o);
    return !selected;
  });
}

export default function Autocomplete(props) {
  // const window = useWindowDimensions();
  const theme = useTheme();
  const {
    scrollableRef,
    scrollX,
    scrollY
  } = useAutocomplete();
  const {
    testID,
    loading,
    ListComponent,
    inputProps: {
      onChangeText,
      defaultValue,
      ...inputProps
    } = {},
    listProps,
    groupBy,
    multiple,
    options,
    style,
    value,
    getOptionValue = option => option.id || option.key || option.value,
    getOptionLabel = option => option.label || option.name || option.title,
    getOptionDescription = option => option.description,
    getOptionIcon = option => option.icon,
    filterOptions = (a, b) => defaultFilterOptions(a, b)
  } = props;
  const {
    value: values,
    onChange: onChangeMultiple
  } = props;
  const {
    value: singleValue,
    onChange: onChangeSingle
  } = props;
  const inputContainerDimensions = useComponentDimensions();
  const chipsDimensions = useComponentDimensions();
  const chipContainerRef = useAnimatedRef();
  const inputContainerRef = useAnimatedRef();
  const inputRef = React.useRef(null);
  const [inputValue, setInputValue] = React.useState(defaultValue || '');
  const [visible, setVisible] = React.useState(false);
  const [focused, setFocused] = React.useState(false);
  const getOptionLabelRef = useLatest(getOptionLabel);
  React.useEffect(() => {
    if (!multiple) {
      if (singleValue) {
        setInputValue(getOptionLabelRef.current(singleValue));
      } else {
        setInputValue('');
      }
    }
  }, [getOptionLabelRef, multiple, singleValue]);

  const changeText = v => {
    // setVisible(true);
    setInputValue(v);
    onChangeText === null || onChangeText === void 0 ? void 0 : onChangeText(v);
  };

  const blur = _ => {
    // console.log('blur', e);
    // setVisible(false);
    setFocused(false);
  };

  const focus = _ => {
    setVisible(true);
    setFocused(true);
  };

  const filterOptionsRef = useLatest(filterOptions);
  const groupByRef = useLatest(groupBy);
  const getOptionValueRef = useLatest(getOptionValue);
  const getOptionDescriptionRef = useLatest(getOptionDescription);
  const isFocusedAndValueIsSameAsSearch = singleValue && focused && inputValue === getOptionLabel(singleValue) || false; // console.log({
  //   singleValue,
  //   focused,
  //   inputValue,
  //   inputValueCompareTo: singleValue && getOptionLabel(singleValue),
  //   isFocusedAndValueIsSameAsSearch,
  // });

  const data = React.useMemo(() => filterOptionsRef.current(removeSelected(options, {
    value,
    multiple,
    getOptionValue: getOptionValueRef.current
  }), {
    isFocusedAndValueIsSameAsSearch,
    getOptionLabel: getOptionLabelRef.current,
    getOptionDescription: getOptionDescriptionRef.current,
    inputValue
  }), [isFocusedAndValueIsSameAsSearch, filterOptionsRef, inputValue, value, multiple, options, getOptionValueRef, getOptionLabelRef, getOptionDescriptionRef]);
  const {
    highlightedIndex,
    handleKeyPress
  } = useHighlighted({
    inputValue,
    setInputValue,
    data,
    multiple,
    values,
    onChangeMultiple,
    onChangeSingle,
    inputRef,
    setVisible
  });
  const sections = React.useMemo(() => {
    if (!groupByRef || !groupByRef.current) {
      return [];
    }

    let grouped = {};
    data === null || data === void 0 ? void 0 : data.forEach(o => {
      const key = groupByRef.current(o);
      const current = grouped[key];

      if (current) {
        current.push(o);
      } else {
        grouped[key] = [o];
      }
    });
    return Object.keys(grouped).map(k => ({
      title: k,
      data: grouped[k]
    }));
  }, [data, groupByRef]);
  const press = React.useCallback(o => {
    if (multiple) {
      var _inputRef$current;

      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
      onChangeMultiple([...(values || []), o]);
      setInputValue('');
    } else {
      onChangeSingle(o);
      setVisible(false);
    }
  }, [multiple, setInputValue, onChangeMultiple, onChangeSingle, values]);
  const remove = React.useCallback(o => {
    if (multiple) {
      const excludeCurrent = (values || []).filter(vo => getOptionValueRef.current(vo) !== getOptionValueRef.current(o));
      onChangeMultiple(excludeCurrent);
    }
  }, [getOptionValueRef, multiple, onChangeMultiple, values]);
  const automaticScrollProps = useAutomaticScroller({
    highlightedIndex,
    sections,
    groupBy
  });
  const minimalDropdownWidth = 250;
  const dropdownWidth = inputContainerDimensions.width;
  const remainingSpace = useDerivedValue(() => inputContainerDimensions.width.value - chipsDimensions.width.value, [inputContainerDimensions.width, chipsDimensions.width]);
  const shouldEnter = useDerivedValue(() => chipsDimensions.height.value > 45 || remainingSpace.value < minimalDropdownWidth, [chipsDimensions.height, remainingSpace]);
  const hasMultipleValue = multiple && (values || []).length > 0; // const animatedInputStyle = useAnimatedStyle(() => {
  //   return {
  //     height: hasMultipleValue
  //       ? shouldEnter
  //         ? chipsDimensions.height.value + 36 + 46
  //         : chipsDimensions.height.value + 36
  //       : undefined,
  //   };
  // }, [chipsDimensions.height, hasMultipleValue, shouldEnter]);

  const highlightedColor = React.useMemo(() => theme.dark ? Color(theme.colors.onBackground).alpha(0.2).rgb().string() : Color(theme.colors.onBackground).alpha(0.1).rgb().string(), [theme.dark, theme.colors.onBackground]);
  const innerListProps = {
    testID: `${testID}-autocomplete-list`,
    keyboardDismissMode: 'on-drag',
    keyboardShouldPersistTaps: 'handled',
    contentInsetAdjustmentBehavior: 'always',
    renderItem: ({
      item,
      index,
      section
    }) => {
      const key = getOptionValue(item);
      let realIndex = index;

      if (section) {
        // what the hell...
        const sectionIndex = sections.indexOf(section);
        const indexesBefore = sections.filter((_, i) => i < sectionIndex).reduce((a, b) => a + b.data.length, 0);
        realIndex = indexesBefore + index;
      }

      return /*#__PURE__*/React.createElement(AutocompleteItem, {
        testID: `${testID}-autocomplete-item-${key}`,
        key: key,
        highlightedColor: highlightedColor,
        title: getOptionLabel(item),
        description: getOptionDescription(item),
        icon: getOptionIcon(item),
        selected: highlightedIndex === realIndex,
        onPress: press,
        option: item
      });
    },
    keyExtractor: item => getOptionValue(item),
    extraData: {
      highlightedIndex
    },
    ...automaticScrollProps
  };
  const SectionListComponent = ListComponent ? ListComponent : SectionList;
  const FinalListComponent = ListComponent ? ListComponent : FlatList;
  const inputStyle = inputProps === null || inputProps === void 0 ? void 0 : inputProps.style;
  const backgroundColor = React.useMemo(() => {
    if (inputStyle) {
      const flattenStyle = StyleSheet.flatten(inputStyle);

      if (flattenStyle.backgroundColor) {
        return flattenStyle.backgroundColor;
      }
    }

    return theme.colors.background;
  }, [theme, inputStyle]);
  const onPressOutside = React.useCallback(() => {
    setVisible(false);
  }, [setVisible]); // console.log({
  //   visible,
  //   inputDim: inputContainerDimensions.dimensions,
  //   chipsDimensions,
  //   shouldEnter,
  // });

  const textInputIcon = singleValue ? getOptionIcon(singleValue) : undefined;
  return /*#__PURE__*/React.createElement(View, {
    style: [styles.menu, style],
    accessibilityRole: "menu",
    testID: testID
  }, /*#__PURE__*/React.createElement(Animated.View, {
    ref: inputContainerRef,
    onLayout: inputContainerDimensions.onLayout,
    style: styles.inputContainer
  }, /*#__PURE__*/React.createElement(TextInput, _extends({
    ref: inputRef,
    onBlur: blur,
    onFocus: focus,
    blurOnSubmit: false,
    value: hasMultipleValue || inputValue.length > 0 ? ' ' : '',
    left: textInputIcon && !props.disableInputPrefixIcon ? /*#__PURE__*/React.createElement(TextInput.Icon, {
      icon: textInputIcon
    }) : undefined
  }, inputProps, {
    style: [inputProps.style, styles.full] // @ts-ignore web only props
    ,
    accessibilityHasPopup: true,
    render: params => {
      return /*#__PURE__*/React.createElement(NativeTextInputWithAnimatedStyles, _extends({}, params, {
        selectTextOnFocus: true,
        value: inputValue,
        onChangeText: changeText,
        onKeyPress: handleKeyPress,
        shouldEnter: shouldEnter,
        chipsHeight: chipsDimensions.height,
        chipsWidth: chipsDimensions.width,
        multiple: multiple
      }));
    }
  })), multiple && visible || !multiple && value ? /*#__PURE__*/React.createElement(IconButton, {
    testID: "autocomplete-close",
    size: 20,
    icon: "close",
    style: styles.closeButton,
    onPress: () => {
      setVisible(false);
      setInputValue('');

      if (multiple) {
        onChangeMultiple([]);
      } else {
        onChangeSingle(undefined);
      }
    }
  }) : null, /*#__PURE__*/React.createElement(IconButton, {
    testID: `${testID}-autocomplete-arrow`,
    style: styles.arrowIconButton,
    icon: visible ? 'menu-up' : 'menu-down',
    onPress: () => {
      if (visible) {
        var _inputRef$current2;

        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.blur();
        setVisible(false);
      } else {
        var _inputRef$current3;

        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.focus();
        setVisible(true);
      }
    }
  })), multiple && /*#__PURE__*/React.createElement(Animated.View, {
    ref: chipContainerRef,
    testID: `${testID}-autocomplete-chips`,
    style: [styles.chipsWrapper, {
      backgroundColor
    }],
    onLayout: chipsDimensions.onLayout,
    pointerEvents: "box-none"
  }, values === null || values === void 0 ? void 0 : values.map(o => /*#__PURE__*/React.createElement(Chip, {
    key: getOptionValue(o),
    onClose: () => remove(o),
    style: styles.chip,
    icon: getOptionIcon(o)
  }, getOptionLabel(o)))), loading ? /*#__PURE__*/React.createElement(ActivityIndicator, {
    style: styles.loading
  }) : null, visible ? /*#__PURE__*/React.createElement(PortalContent, {
    visible: visible,
    onPressOutside: onPressOutside
  }, /*#__PURE__*/React.createElement(PositionedSurface, {
    scrollableRef: scrollableRef,
    theme: theme,
    dropdownWidth: dropdownWidth,
    inputContainerRef: inputContainerRef,
    inputContainerHeight: inputContainerDimensions.height,
    scrollX: scrollX,
    scrollY: scrollY
  }, groupBy ? /*#__PURE__*/React.createElement(SectionListComponent, _extends({}, listProps, innerListProps, {
    sections: sections,
    renderSectionHeader: ({
      section: {
        title
      }
    }) => /*#__PURE__*/React.createElement(List.Subheader, null, title),
    onScrollToIndexFailed: info => {
      // TODO: make sure everything uses fixed heights so this error won't be there
      // e.g.:  getItemLayout={getSectionListItemLayout}
      console.error(info);
    }
  })) : /*#__PURE__*/React.createElement(FinalListComponent, _extends({}, listProps, innerListProps, {
    getItemLayout: getFlatListItemLayout,
    data: data
  })))) : null);
}
const AnimatedNativeInput = Animated.createAnimatedComponent(NativeTextInput);
const NativeTextInputWithAnimatedStyles = /*#__PURE__*/React.forwardRef(({
  shouldEnter,
  chipsHeight,
  chipsWidth,
  style,
  multiple,
  ...rest
}, forwardedRef) => {
  const originalStyle = StyleSheet.flatten(style);
  const orgTop = Number(originalStyle.paddingTop) || 0;
  const orgLeft = Number(originalStyle.paddingLeft) || 0;
  const height = Number(originalStyle.height) || 0;
  const animatedStyle = useAnimatedStyle(() => {
    if (!multiple) {
      return {};
    }

    const addTop = shouldEnter.value ? chipsHeight.value + 18 : 18;
    return {
      paddingTop: orgTop + addTop,
      paddingLeft: orgLeft + (shouldEnter.value ? 0 : chipsWidth.value),
      height: height + addTop
    };
  }, [multiple, orgLeft, orgTop, shouldEnter, chipsHeight, chipsWidth]);
  return /*#__PURE__*/React.createElement(AnimatedNativeInput, _extends({
    ref: forwardedRef
  }, rest, {
    style: [style, animatedStyle]
  }));
});
const styles = StyleSheet.create({
  modalBackground: {
    flex: 1
  },
  menu: {
    position: 'relative'
  },
  chipsWrapper: {
    flexDirection: 'row',
    position: 'absolute',
    flexWrap: 'wrap',
    top: 32,
    left: 12
  },
  chip: {
    marginRight: 6,
    marginBottom: 6,
    flexShrink: 1
  },
  inputContainer: {
    alignItems: 'center',
    flexDirection: 'row'
  },
  full: {
    flex: 1
  },
  closeButton: {
    position: 'absolute',
    bottom: 6,
    right: 36
  },
  arrowIconButton: {
    position: 'absolute',
    bottom: 5,
    right: 0
  },
  loading: {
    position: 'absolute',
    right: 12,
    top: 24
  }
});
//# sourceMappingURL=Autocomplete.js.map